#!/usr/bin/env python
# coding: utf-8

# Convert source_new.txt to c structure

c_file_header = """#include <stdlib.h>

#include "jl_types.h"

/* Autogenerated file, do not modify */

enum cmd_e {
    JL_CMD_NONE = 0,
    JL_CMD_WRITE,
    JL_CMD_BWRITE,
    JL_CMD_DELAY
};

enum cmd_flag_e {
    JL_CMD_FLAG_DA = 0,
    JL_CMD_FLAG_IDA,
    /* burst write size in word */
};

struct cmd_line_s {
    jl_uint8 cmd; //cmd=1, write;cmd=2, burst write;cmd=3, dealy
    jl_uint8 flag; //flag=0, DAï¼›flag=1, IDA;if cmd==2,flag=burst size
    jl_uint32 addr; //regiter SMI access address
    jl_uint32 val; //register value;dealy time ms
}__attribute__ ((__packed__));

const struct cmd_line_s cmd_line_set[] = {
"""
JL_CMD_WRITE = 1
JL_CMD_BWRITE = 2
JL_CMD_DELAY = 3
JL_CMD_FLAG_DA = 0
JL_CMD_FLAG_IDA = 1

normal_struct_line = "\t{{{cmd}, {flag}, {smi_addr}, {value}}},\n"
last_struct_line = "\t{{{cmd}, {flag}, {smi_addr}, {value}}}\n"

def getCommandLines(lines):
    new_lines = []
    skip_ee_specified = 0
    for i, line in  enumerate(lines):
        #Split line into string list
        code = line.strip().split(" ")

        #Bypass if an empty line
        if line in ["\n", '\r\n']:
            continue

        #Bypass if a commented line
        if (code[0].startswith('#') or code[0].startswith(';')):
            continue

        #Bypass EEprom specified settings
        if (code[0] == "ONLY_FOR_EE"):
            assert(len(code) == 2)
            if (code[1] == "BEGIN"):
                if (skip_ee_specified == 1):
                    raise Exception("Error: 'ONLY_FOR_EE' expected 'END' before 'BEGIN'!!!")
                skip_ee_specified = 1
            elif (code[1] == "END"):
                if (skip_ee_specified == 0):
                    raise Exception("Error: 'ONLY_FOR_EE' expected 'BEGIN' before 'END'!!!")
                skip_ee_specified = 0
            else:
                raise Exception("Error: 'ONLY_FOR_EE' followed by unknown string [%s]!!!" %(code[1]))

            continue

        if (skip_ee_specified == 1):
            continue

        if (code[0] == "ONLY_FOR_SDK"):
            continue

        new_lines.append(line)

    return new_lines


def main(source, out):
    try:
        infile = open(source, 'r')
    except IOError:
        print("Open %s failed." %(source))
        exit(1)

    outfile = open(out, 'w')

    outfile.write(c_file_header)

    lines = infile.readlines()
    new_lines = getCommandLines(lines)

    line_num = len(new_lines)
    for index, line in enumerate(new_lines):
        #Get the C structure array line format
        struct_line = ""
        if (index ==  line_num - 1):
            struct_line = last_struct_line
        else:
            struct_line = normal_struct_line

        #Split line into string list
        code = line.strip().split(" ")

        if (code[0] == "WRITE"):
            # SMI Register Direct Access
            if (int(code[1]) == JL_CMD_FLAG_DA):
                addr = code[2]
                value = code[3]
                s = struct_line.format(cmd = JL_CMD_WRITE, flag = JL_CMD_FLAG_DA, smi_addr = addr, value = value)
                outfile.write(s)
            # SMI Register Indirect Direct Access
            if (int(code[1]) == JL_CMD_FLAG_IDA):
                addr = code[2]
                value = code[3]
                s = struct_line.format(cmd = JL_CMD_WRITE, flag = JL_CMD_FLAG_IDA, smi_addr = addr, value = value)
                outfile.write(s)
            continue

        if (code[0] == "DELAY"):
            delay = code[1]
            s = struct_line.format(cmd = JL_CMD_DELAY, flag = 0, smi_addr = 0, value = delay)
            outfile.write(s)
            continue

        if (code[0] == "BWRITE"):
            # SMI Register Burst Indirect Access
            size = int(code[1])
            addr = code[2]
            value= code[3]
            if (size < 1) or (size > 8):
                raise Exception("Invalid Burst size: {}".format(size))
            s = struct_line.format(cmd = JL_CMD_BWRITE, flag = size, smi_addr = addr, value = value)
            outfile.write(s)
            for i in range(4, 4 + size - 1):
                s = struct_line.format(cmd = 0, flag = 0, smi_addr = 0, value = code[i])
                outfile.write(s)
            continue

        raise Exception("Error: Unknown line [%s]!!" %(line))

    s = "};\n"
    outfile.write(s)

    infile.close()
    outfile.close()


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description='Convert Config Source file to C Structure file')

    parser.add_argument(
        '--source', nargs=1, default=["config_source.txt"], help='path of config source file as input')

    parser.add_argument(
        '--out', nargs=1, default=["config.h"], help='path of C structure output file')

    args = parser.parse_args() # expose args to global

    main(args.source[0], args.out[0])

